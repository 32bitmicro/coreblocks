"""
This type stub file was generated by pyright.
"""

from typing import Any, NoReturn, Optional, overload
from transactron.utils import ValueLike, ShapeLike, StatementLike
from collections.abc import Iterable, MutableSequence
from . import wiring
from ..hdl import MemoryInstance
from ..hdl._mem import MemorySimRead

__all__ = ["WritePort", "ReadPort", "Memory"]
class WritePort:
    """A memory write port.

    Parameters
    ----------
    signature : :class:`WritePort.Signature`
        The signature of the port.
    memory : :class:`Memory` or ``None``
        Memory associated with the port.
    domain : str
        Clock domain. Defaults to ``"sync"``. Writes have a latency of 1 clock cycle.

    Attributes
    ----------
    signature : :class:`WritePort.Signature`
    memory : :class:`Memory`
    domain : str
    """
    class Signature(wiring.Signature):
        """A signature of a write port.

        Parameters
        ----------
        addr_width : int
            Address width in bits. If the port is associated with a :class:`Memory`,
            it must be equal to :py:`ceil_log2(memory.depth)`.
        shape : :ref:`shape-like <lang-shapelike>` object
            The shape of the port data. If the port is associated with a :class:`Memory`,
            it must be equal to its element shape.
        granularity : int or ``None``
            Port granularity. If ``None``, the entire storage element is written at once.
            Otherwise, determines the size of access covered by a single bit of ``en``.
            One of the following must hold:

            - ``granularity is None``, in which case ``en_width == 1``, or
            - ``shape == unsigned(data_width)`` and ``data_width == 0 or data_width % granularity == 0`` in which case ``en_width == data_width // granularity`` (or 0 if ``data_width == 0``)
            - ``shape == amaranth.lib.data.ArrayLayout(_, elem_count)`` and ``elem_count == 0 or elem_count % granularity == 0`` in which case ``en_width == elem_count // granularity`` (or 0 if ``elem_count == 0``)

        Members
        -------
        addr: :py:`unsigned(data_width)`
        data: ``shape``
        en: :py:`unsigned(en_width)`
        """
        def __init__(self, *, addr_width: int, shape: ShapeLike, granularity: Optional[int]=...) -> None:
            ...
        
        @property
        def addr_width(self) -> int:
            ...
        
        @property
        def shape(self) -> ShapeLike:
            ...
        
        @property
        def granularity(self) -> Optional[int]:
            ...
        
        def __repr__(self) -> str:
            ...
        
    
    
    def __init__(self, signature: Signature, *, memory: Optional[Memory], domain: str) -> None:
        ...
    
    @property
    def signature(self) -> Signature:
        ...
    
    @property
    def memory(self) -> Memory:
        ...
    
    @property
    def domain(self) -> str:
        ...
    


class ReadPort:
    """A memory read port.

    Parameters
    ----------
    signature : :class:`ReadPort.Signature`
        The signature of the port.
    memory : :class:`Memory`
        Memory associated with the port.
    domain : str
        Clock domain. Defaults to ``"sync"``. If set to ``"comb"``, the port is asynchronous.
        Otherwise, the read data becomes available on the next clock cycle.
    transparent_for : iterable of :class:`WritePort`
        The set of write ports that this read port should be transparent with. All ports
        must belong to the same memory and the same clock domain.

    Attributes
    ----------
    signature : :class:`ReadPort.Signature`
    memory : :class:`Memory`
    domain : str
    transparent_for : tuple of :class:`WritePort`
    """
    class Signature(wiring.Signature):
        """A signature of a read port.

        Parameters
        ----------
        addr_width : int
            Address width in bits. If the port is associated with a :class:`Memory`,
            it must be equal to :py:`ceil_log2(memory.depth)`.
        shape : :ref:`shape-like <lang-shapelike>` object
            The shape of the port data. If the port is associated with a :class:`Memory`,
            it must be equal to its element shape.

        Members
        -------
        addr: :py:`unsigned(data_width)`
        data: ``shape``
        en: :py:`unsigned(1)`
            The enable signal. If ``domain == "comb"``, this is tied to ``Const(1)``.
            Otherwise it is a signal with ``init=1``.
        """
        def __init__(self, *, addr_width: int, shape: ShapeLike) -> None:
            ...
        
        @property
        def addr_width(self) -> int:
            ...
        
        @property
        def shape(self) -> ShapeLike:
            ...
        
        def __repr__(self) -> str:
            ...
        
    
    
    def __init__(self, signature: Signature, *, memory: Memory, domain: str, transparent_for: Iterable[WritePort] = ...) -> None:
        ...
    
    @property
    def signature(self) -> Signature:
        ...
    
    @property
    def memory(self) -> Memory:
        ...
    
    @property
    def domain(self) -> str:
        ...
    
    @property
    def transparent_for(self) -> tuple[WritePort, ...]:
        ...
    


class Memory(wiring.Component):
    """A word addressable storage.

    Parameters
    ----------
    shape : :ref:`shape-like <lang-shapelike>` object
        The shape of a single element of the storage.
    depth : int
        Word count. This memory contains ``depth`` storage elements.
    init : iterable of int or of any objects accepted by ``shape.const()``
        Initial values. At power on, each storage element in this memory is initialized to
        the corresponding element of ``init``, if any, or to the default value of ``shape`` otherwise.
        Uninitialized memories are not currently supported.
    attrs : dict
        Dictionary of synthesis attributes.

    Attributes
    ----------
    shape : :ref:`shape-like <lang-shapelike>`
    depth : int
    init : :class:`Memory.Init`
    attrs : dict
    r_ports : tuple of :class:`ReadPort`
    w_ports : tuple of :class:`WritePort`
    """
    class Init(MutableSequence):
        """Initial data of a :class:`Memory`.

        This is a container implementing the ``MutableSequence`` protocol, enforcing two constraints:

        - the length is immutable and must equal ``depth``
        - if ``shape`` is a :class:`ShapeCastable`, each element can be cast to ``shape`` via :py:`shape.const()`
        - otherwise, each element is an :py:`int`
        """
        def __init__(self, items: Iterable[ValueLike], *, shape: ShapeLike, depth: int) -> None:
            ...
        
        @overload
        def __getitem__(self, index: int) -> Any:
            ...
        
        @overload
        def __getitem__(self, index: slice) -> list:
            ...
        
        @overload
        def __setitem__(self, index: int, value) -> None:
            ...
        
        @overload
        def __setitem__(self, index: slice, value) -> None:
            ...
        
        def __delitem__(self, index: int | slice) -> NoReturn:
            ...
        
        def insert(self, index: int, value) -> NoReturn:
            ...
        
        def __len__(self) -> int:
            ...
        
        @property
        def depth(self) -> int:
            ...
        
        @property
        def shape(self) -> ShapeLike:
            ...
        
        def __repr__(self) -> str:
            ...
        
    
    
    def __init__(self, *, depth: int, shape: ShapeLike, init: Init, attrs: dict[str, Any] =..., src_loc_at=..., src_loc=...) -> None:
        ...
    
    def read_port(self, *, domain: str =..., transparent_for: Iterable[WritePort] =...) -> ReadPort:
        """Adds a new read port and returns it.

        Equivalent to creating a :class:`ReadPort` with a signature of :py:`ReadPort.Signature(addr_width=ceil_log2(self.depth), shape=self.shape)`
        """
        ...
    
    def write_port(self, *, domain: str =..., granularity: Optional[int] =...) -> WritePort:
        """Adds a new write port and returns it.

        Equivalent to creating a :class:`WritePort` with a signature of :py:`WritePort.Signature(addr_width=ceil_log2(self.depth), shape=self.shape, granularity=granularity)`
        """
        ...
    
    @property
    def depth(self) -> int:
        ...
    
    @property
    def shape(self) -> ShapeLike:
        ...
    
    @property
    def init(self) -> Init:
        ...
    
    @property
    def attrs(self) -> dict[str, Any]:
        ...
    
    @property
    def w_ports(self) -> tuple[WritePort, ...]:
        """Returns a tuple of all write ports defined so far."""
        ...
    
    @property
    def r_ports(self) -> tuple[ReadPort, ...]:
        """Returns a tuple of all read ports defined so far."""
        ...
    
    def elaborate(self, platform) -> MemoryInstance:
        ...
    
    def __getitem__(self, index) -> MemorySimRead:
        """Simulation only."""
        ...
    


